(function(){

	'use strict'

	var pg = require('pg')
	var bunyan = require('bunyan')
	var F = require('functionally')

	var appConfig = require('./config/app')

	var emptyFn = function(){}

	var logger
	var info
	var error

	function ensureLogger(){

		if (!logger){
			logger = require('./loggerFactory')('sql')

			info  = logger.info
			error = logger.error
		}
	}


	function onError(){
		error.apply(this, arguments)
	}

	function onSuccess(query, preparedData){
		var args = [query]
		preparedData && args.push(preparedData)

		info.apply(logger, args)
	}

	function getQueryInfo(sqlQuery){
		var params

		if (typeof sqlQuery != 'string'){

			params = typeof sqlQuery.isParameterized == 'function' &&
						typeof sqlQuery.getParams == 'function' &&
						sqlQuery.isParameterized() &&
						sqlQuery.getParams()

			if (params && Array.isArray(params)){
				//this can be either a parameterized
				//or a prepared query

				if (sqlQuery.isPrepared()){
					sqlQuery = {
						name: sqlQuery.name,
						text: sqlQuery.valueOf(),
						values: params
					}
					info('executing prepared query')
				} else {
					sqlQuery = sqlQuery.valueOf()
					info('executing parameterized query')
				}
			} else {
				sqlQuery += ''
			}
		}

		return {
			params: params? params: undefined,
			sqlQuery: sqlQuery
		}
	}

	function asArray(sqlQuery){
		var info = getQueryInfo(sqlQuery)
		var params = info.params
		var args

		sqlQuery = info.sqlQuery
		args = [sqlQuery]
		params && args.push(params)

		return args
	}

	module.exports = function(connString){

		var connect = function(callback){

			ensureLogger()

			callback = callback || function(){}

			pg.connect(connString, function(err, client, done){
				if (err){
					return onError(err, 'Error connecting to the database.')
				}

				callback(err, client, done)
			})
		}

		/**
		 * With the given sql client, executes the query and calls the callback with the err and the result
		 *
		 * @param  {SqlClient}   client
		 * @param  {String/Array}   query
		 * @param  {Function} callback
		 *
		 * NOTE: This does NOT free the client after the query is executed.
		 */
		var clientExecute = function(client, query, callback){
			var args = Array.isArray(query)?
							query.concat():
							[query]

			args.push(function(err, result){
				if (err){
					onError(err, query)
				} else {
					onSuccess(query)
				}

				callback(err, result)
			})

			client.query.apply(client, args)
		}

		/**
		 * Executes a single query and calls callback with err and the query result
		 *
		 * @param  {String/Array}   sqlQuery
		 * @param  {Function} callback
		 *
		 * NOTE: This frees the sql client it uses internally.
		 */
		var query = function(sqlQuery, callback){

			callback = callback || function(){}

			connect(function(err, client, done){

				if (err){
					//free the client so it can be reused
					done()
					return callback(err)
				}

				clientExecute(client, asArray(sqlQuery), function(err, result){
					//free the client so it can be reused
					done()
					callback(err, result)
				})
			})
		}

		/**
		 * Executes the given queries, in sequence and calls the callback. Does NOT free the sql client
		 *
		 * @param  {String/Array}   queries
		 * @param  {Function} callback
		 *
		 * The callback will be called with 4 arguments:
		 *
		 *  * client - the sql client connection.
		 *  * done - fn that will be used to free the client
		 *  * err - the error object
		 *  * results - an array with the results of the queries
		 *
		 */
		var doSequence = function(queries, callback){

			callback = callback || emptyFn

			connect(function(err, client, done){

				var results = []

				if (err || !Array.isArray(queries) || !queries.length){
					callback(client, done, err, results)
				}

				var fns = queries.map(function(query, index, arr){
					return function(err, result){

						results.push(result)

						var nextIndex = index + 1

						if (err || nextIndex == arr.length){
							return callback(client, done, err, results, index)
						}

						clientExecute(client, asArray(queries[nextIndex]), fns[nextIndex])
					}
				})

				clientExecute(client, asArray(queries[0]), fns[0])

			})
		}

		/**
		 * Executes the given queries in sequence, and frees the client after they are done
		 *
		 * @param  {Array}   queries
		 * @param  {Function} callback
		 *
		 * The following args will be passed to the callback:
		 *
		 *  * err - an error descriptor
		 *  * results - an array with the results of each sql statement in the given queries array
		 *
		 * After the queries are executed, the sql client is freed and the callback is called.
		 */
		var sequence = function(queries, callback){
			callback = callback || emptyFn

			doSequence(queries, function(client, done, err, results){
				done()
				callback(err, results)
			})
		}

		var rollback = function(client, failedQuery, callback){
			onError('rollback transaction since we failed at ', failedQuery)

			clientExecute(client, 'ROLLBACK;', function(err){
				callback()
			})
		}

		/**
		 * Executes the given queries in a transaction.
		 * @param  {Array}   queries
		 * @param  {Function} callback The function to be called when the transaction is complete.
		 * Since the transaction can have multiple sql statements, the callback fn will be called with an err object and a results array. The results array contains the result of every sql statement in the transaction. NOTE: if there was just one sql statement in the transaction, the second argument passed to the callback is no longer an array but the result of that sql statement.
		 *
		 * If the transaction fails, a rollback is executed.
		 */
		var transaction = function(queries, callback){

			if (queries && !Array.isArray(queries)){
				queries = [queries]
			}

			queries.unshift('BEGIN;')
			queries.push('COMMIT;')

			doSequence(queries, function(client, done, err, results, index){

				results.shift()
				results.pop()

				if (results.length == 1){
					results = results[0]
				}

				if (err){
					rollback(client, queries[index], function(){
						done()
						callback(err, results)
					})

					return
				}

				done()

				callback(err, results)
			})
		}

		return {
			query      : query,
			transaction: transaction,
			sequence   : sequence
		}
	}
})()